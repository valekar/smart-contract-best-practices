{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ethereum Smart Contract Security Best Practices","text":"<p>Tip</p> <p>Thank you for visiting the Smart Contract Security Best Practices. Please note that this resource is no longer actively maintained. Instead, we recommend visiting the Smart Contract Security Field Guide. The Smart Contract Security Field Guide is regularly updated and curated by the same security engineer who previously contributed to the Best Practices guide.</p> <p>This document provides a baseline knowledge of security considerations for intermediate Solidity programmers. It is maintained by ConsenSys Diligence, with contributions from our friends in the broader Ethereum community.</p> <p>Our amazing community has also provided translations in Chinese and Vietnamese.</p>"},{"location":"#where-to-start","title":"Where to start?","text":"<ul> <li>General Philosophy describes the smart contract security mindset</li> <li>Development Recommendations contains examples of good code patterns</li> <li>Known Attacks describes the different classes of vulnerabilities to avoid</li> <li>Security Tools lists tools for improving code quality, and detecting   vulnerabilities</li> <li>Bug Bounties List of bug bounties in the ecosystem.</li> </ul>"},{"location":"#contributions-are-welcome","title":"Contributions are welcome!","text":"<p>Feel free to submit a pull request, with anything from small fixes, to full new sections. If you are writing new content, please reference the contributing page for guidance on style.</p> <p>See the issues for topics that need to be covered or updated.</p>"},{"location":"bug-bounty-programs/","title":"Bug Bounty Programs","text":"<p>Tip</p> <p>Looking for comprehensive information on setting up, managing, and operating a bug bounty program? Please refer to the Smart Contract Security Field Guide's bug bounty guide. This resource provides in-depth, up-to-date knowledge and strategies that are paramount for running a successful bug bounty program.</p> <p>Over the course of time Ethereum security has evolved to include different flavours of bug bounty programs which will be detailed below:</p>"},{"location":"bug-bounty-programs/#bug-bounty-platforms","title":"Bug Bounty Platforms","text":"<p>The first category are bug bounty platforms wherein a development team submits their project to a platform that either manages the programme for them or simply lists their project for exposure and reach toward interested security researchers. These platforms are further divided by type. The first are web3 native platforms hosting the majority of smart contract and frontend bug bounty programmes you'll find and the second are traditional platforms hosting majorly programmes with the frontend of centralized exchanges in scope. Finally, there are bounty collaboration platforms where developers are paid to code and implement new features or smart contracts.</p> <p>Web3 native platforms:</p> <ul> <li>Immunefi</li> <li>HackenProof</li> </ul> <p>Traditional platforms:</p> <ul> <li>HackerOne</li> <li>Bugcrowd</li> </ul> <p>Bounty collaboration platforms:</p> <ul> <li>Gitcoin</li> </ul>"},{"location":"bug-bounty-programs/#crowd-sourced-security-solutions","title":"Crowd-sourced Security Solutions","text":"<p>In response to the high demand and low supply for professional smart contract security review firms, a few crowd sourced solutions have emerged to solve the issue. They all employ a bug bounty-esque model hence inclusion on this list. They call them \"audit contests\" with freelance security researchers scrambling to find and report vulnerabilities within a set time period i.e two weeks with payouts only being issued for successful findings. Examples are listed below:</p> <ul> <li>Code4rena</li> </ul>"},{"location":"bug-bounty-programs/#project-managed-bounties","title":"Project Managed Bounties","text":"<p>The final category for now consists of bug bounty programmes that are directly managed by the project team itself and are often focused on smart contracts in their scope whether that's contributing to their features or breaking them.</p> <p>Issues and PRs are welcome to add new bounties, or remove those which are no longer active.</p> <ul> <li>Airswap</li> <li>Ethereum Foundation: Has a large scope, including   clients, Solidity and Vyper, and more.</li> <li>Etherscan.io</li> <li>ImmutableSoft</li> <li>0xProject</li> <li>Parity: Includes client and contract code</li> </ul>"},{"location":"about/","title":"Contributing to the Smart Contract Security Best Practices","text":"<p>Please take a moment to review this document to make the contribution process easy and effective for everyone involved. Following these guidelines helps to communicate that you respect the maintainers' time in managing and developing this open-source project. They should reciprocate that respect in addressing your issue or assessing pull requests.</p>"},{"location":"about/#using-the-issue-tracker","title":"Using the Issue Tracker","text":"<p>The issue tracker is the preferred channel for feature requests and submitting pull requests. There are some cases where the issue tracker should not be used:</p> <ul> <li>Please do not use the issue tracker for personal support requests to ask     the community for help. There are many Discord and Telegram communities     around Smart Contract development where people will be more than happy to     help.</li> <li>Please do not derail or troll issues. Keep the discussion on topic and     respect the opinions of others.</li> </ul>"},{"location":"about/#content-related-issues","title":"Content-related Issues","text":"<p>Sections on attacks and security best practices should include examples and further reading. Security-related information is bound to change over time, however. Content-related issues should flag areas that need more explanations or contain outdated content.</p> <p>A well-written issue flagging areas of the Best Practices that need attention are very beneficial - thank you! Some guidelines for content-related issues:</p> <ol> <li>Use the GitHub issue search: Check if the issue has already been    reported. If the issue is already present, use a thumbs-up reaction to    help the developers prioritize.</li> <li>Check if the issue has been fixed: Try checking out open pull requests     and development branches. The problem you are looking to flag might already     be fixed.</li> <li>Isolate the problem: An excellent content-related issue shouldn't leave     others needing to chase you up for more information. Please try to be as     detailed as possible. If content needs fixing across multiple areas,     please flag one issue for each case.</li> </ol>"},{"location":"about/#feature-requests","title":"Feature Requests","text":"<p>Feature requests are welcome. But take a moment to find out whether your idea fits with the scope and aims of the project. It's up to you to make a solid case to convince the maintainers of the merits of an additional piece of content. Please provide as much detail and context as possible. Keep in mind that the Best Practices do not aim to mirror general security considerations that can be found in the project's respective documentation. Additional content to the repository should be original and flag potential pitfalls developers might encounter when building Smart Contract systems.</p>"},{"location":"about/#pull-requests","title":"Pull Requests","text":"<p>Reasonable pull requests - patches, improvements, new content - are a fantastic help. They should remain focused in scope and avoid containing unrelated commits. Please ask first before embarking on any significant pull request (e.g. adding new content, refactoring example code). Otherwise, you risk spending a lot of time working on something that the maintainers might not want to merge into the project. Please adhere to the coding conventions used throughout the project (indentation, comments, etc.). Adhering to the following this process is the best way to get your work merged:</p> <ol> <li>Fork the repo, clone your fork,    and configure the remotes:     <pre><code># Clone your fork of the repo into the current directory\ngit clone https://github.com/&lt;your-username&gt;/&lt;repo-name&gt;\n# Navigate to the newly cloned directory\ncd &lt;repo-name&gt;\n# Assign the original repo to a remote called \"upstream\"\ngit remote add upstream https://github.com/&lt;upsteam-owner&gt;/&lt;repo-name&gt;\n</code></pre></li> <li>If you cloned a while ago, get the latest changes from upstream:     <pre><code>git checkout &lt;dev-branch&gt;\ngit pull upstream &lt;dev-branch&gt;\n</code></pre></li> <li>Create a new topic branch (off the main project development branch) to    contain your new content, change, or fix:     <pre><code>git checkout -b &lt;topic-branch-name&gt;\n</code></pre></li> <li>Commit your changes in logical chunks. Please adhere to these git commit    message guidelines    or your code is unlikely to be merged into the main project. Use Git's    interactive rebase    feature to tidy up your commits before making them public.</li> <li>Locally merge (or rebase) the upstream development branch into your topic branch:     <pre><code>git pull [--rebase] upstream &lt;dev-branch&gt;\n</code></pre></li> <li>Push your topic branch up to your fork:     <pre><code>git push origin &lt;topic-branch-name&gt;\n</code></pre></li> <li>Open a Pull Request    with a clear title and description.</li> </ol>"},{"location":"about/#style-guidelines","title":"Style Guidelines","text":"<p>To maintain a consistent writing style across the documents, a few considerations need to be taken.</p> <ol> <li>Succinctness: Use precise language and don't assume knowledge beyond     Solidity and Ethereum basics.</li> <li>Show, don't tell: Examples speak more than a lengthy exposition.     Provide code examples where relevant and raise issues or best practices     in the code around them.</li> <li>Give credit: When further reading is recommended or resources are     available that corroborate security issues, they should contain credit     and link to the original resource.</li> <li>Label code: Examples containing code must be labeled as insecure or     secure where relevant. Specifically, in content regarding attacks,     vulnerable code should be preceded by <code>// INSECURE</code>.</li> </ol>"},{"location":"about/license/","title":"License","text":"<p>Copyright 2016 Smart Contract Best Practices Authors</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"attacks/","title":"Index","text":"<p>Tip</p> <p>Seeking more detailed information on smart contract attacks? The Smart Contract Security Field Guide offers an extensive range of attack strategies with in-depth explanations on vulnerabilities, including new code samples for a hands-on learning experience. Enhance your understanding and stay ahead of potential threats by visiting this continuously updated resource.</p> <p>The following is a list of known attacks which you should be aware of, and defend against when writing smart contracts.</p> Category Description Reentrancy Intra- and inter-function reentrancy attacks and potentially faulty solutions to them. Oracle Manipulation Manipulation of external data providers and potential solutions to oracle security issues. Frontrunning A definition and taxonomy around frontrunning and related attacks. Timestamp Dependence Attacks relating to the timing of a transaction. Insecure Arithmetic Integer overflows and underflows. Denial of Service Denial of service attacks through unexpected reverts and the block gas limit. Griefing Attacks relating to bad faith players around a smart contract system. Force Feeding Forcing Ether to be sent to smart contracts to manipulate balance checks. Deprecated/Historical Attacks that are part of Ethereum's history and vulnerabilities that have been fixes on a (Solidity) compiler level. More Where to find more information about vulnerabilities and weaknesses."},{"location":"attacks/denial-of-service/","title":"Denial of Service","text":""},{"location":"attacks/denial-of-service/#dos-with-unexpected-revert","title":"DoS with (Unexpected) revert","text":"<p>Consider a simple auction contract:</p> <pre><code>// INSECURE\ncontract Auction {\n    address currentLeader;\n    uint highestBid;\n\n    function bid() payable {\n        require(msg.value &gt; highestBid);\n\n        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert\n\n        currentLeader = msg.sender;\n        highestBid = msg.value;\n    }\n}\n</code></pre> <p>If attacker bids using a smart contract which has a fallback function that reverts any payment, the attacker can win any auction. When it tries to refund the old leader, it reverts if the refund fails. This means that a malicious bidder can become the leader while making sure that any refunds to their address will always fail. In this way, they can prevent anyone else from calling the <code>bid()</code> function, and stay the leader forever. A recommendation is to set up a pull payment system instead, as described earlier.</p> <p>Another example is when a contract may iterate through an array to pay users (e.g., supporters in a crowdfunding contract). It's common to want to make sure that each payment succeeds. If not, one should revert. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never complete. No one gets paid because one address is forcing an error.</p> <pre><code>address[] private refundAddresses;\nmapping (address =&gt; uint) public refunds;\n\n// bad\nfunction refundAll() public {\n    for(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated\n        require(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds\n    }\n}\n</code></pre> <p>Again, the recommended solution is to favor pull over push payments.</p> <p>See SWC-113</p>"},{"location":"attacks/denial-of-service/#dos-with-block-gas-limit","title":"DoS with Block Gas Limit","text":"<p>Each block has an upper bound on the amount of gas that can be spent, and thus the amount computation that can be done. This is the Block Gas Limit. If the gas spent exceeds this limit, the transaction will fail. This leads to a couple of possible Denial of Service vectors:</p>"},{"location":"attacks/denial-of-service/#gas-limit-dos-on-a-contract-via-unbounded-operations","title":"Gas Limit DoS on a Contract via Unbounded Operations","text":"<p>You may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit.</p> <p>This can lead to problems even in the absence of an intentional attack. However, it's especially bad if an attacker can manipulate the amount of gas needed. In the case of the previous example, the attacker could add a bunch of addresses, each of which needs to get a very small refund. The gas cost of refunding each of the attacker's addresses could, therefore, end up being more than the gas limit, blocking the refund transaction from happening at all.</p> <p>This is another reason to favor pull over push payments.</p> <p>If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you've gone, and be able to resume from that point, as in the following example:</p> <pre><code>struct Payee {\n    address addr;\n    uint256 value;\n}\n\nPayee[] payees;\nuint256 nextPayeeIndex;\n\nfunction payOut() {\n    uint256 i = nextPayeeIndex;\n    while (i &lt; payees.length &amp;&amp; gasleft() &gt; 200000) {\n      payees[i].addr.send(payees[i].value);\n      i++;\n    }\n    nextPayeeIndex = i;\n}\n</code></pre> <p>You will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the <code>payOut()</code> function. So only use this pattern if absolutely necessary.</p>"},{"location":"attacks/denial-of-service/#gas-limit-dos-on-the-network-via-block-stuffing","title":"Gas Limit DoS on the Network via Block Stuffing","text":"<p>Even if your contract does not contain an unbounded loop, an attacker can prevent other transactions from being included in the blockchain for several blocks by placing computationally intensive transactions with a high enough gas price.</p> <p>To do this, the attacker can issue several transactions which will consume the entire gas limit, with a high enough gas price to be included as soon as the next block is mined. No gas price can guarantee inclusion in the block, but the higher the price is, the higher is the chance.</p> <p>If the attack succeeds, no other transactions will be included in the block. Sometimes, an attacker's goal is to block transactions to a specific contract prior to specific time.</p> <p>This attack was conducted on Fomo3D, a gambling app. The app was designed to reward the last address that purchased a \"key\". Each key purchase extended the timer, and the game ended once the timer went to 0. The attacker bought a key and then stuffed 13 blocks in a row until the timer was triggered and the payout was released. Transactions sent by attacker took 7.9 million gas on each block, so the gas limit allowed a few small \"send\" transactions (which take 21,000 gas each), but disallowed any calls to the <code>buyKey()</code> function (which costs 300,000+ gas).</p> <p>A Block Stuffing attack can be used on any contract requiring an action within a certain time period. However, as with any attack, it is only profitable when the expected reward exceeds its cost. The cost of this attack is directly proportional to the number of blocks which need to be stuffed. If a large payout can be obtained by preventing actions from other participants, your contract will likely be targeted by such an attack.</p> <p>See SWC-128</p>"},{"location":"attacks/deprecated/","title":"Deprecated/Historical","text":"<p>These are attacks which are no longer possible due to changes in the protocol or improvements to solidity. They are recorded here for posterity and awareness.</p>"},{"location":"attacks/deprecated/#call-depth-attack-deprecated","title":"Call Depth Attack (deprecated)","text":"<p>As of the EIP 150 hardfork, call depth attacks are no longer relevant<sup>*</sup> (all gas would be consumed well before reaching the 1024 call depth limit).</p>"},{"location":"attacks/deprecated/#constantinople-reentrancy-attack","title":"Constantinople Reentrancy Attack","text":"<p>On January 16<sup>th</sup>, 2019, Constantinople protocol upgrade was delayed due to a security vulnerability enabled by EIP 1283. EIP 1283: Net gas metering for SSTORE without dirty maps proposes changes to reduce excessive gas costs on dirty storage writes.</p> <p>This change led to possibility of a new reentrancy vector making previously known secure withdrawal patterns (<code>.send()</code> and <code>.transfer()</code>) unsafe in specific situations<sup>*</sup>, where the attacker could hijack the control flow and use the remaining gas enabled by EIP 1283, leading to vulnerabilities due to reentrancy.</p>"},{"location":"attacks/force-feeding/","title":"Force Feeding","text":"<p>Tip</p> <p>Thank you for visiting the Smart Contract Security Best Practices. Please note that this resource is no longer actively maintained. Instead, we recommend visiting the Smart Contract Security Field Guide. The Field Guide is regularly updated and curated by the same security engineer who previously contributed to the Best Practices guide.</p> <p>The resource on unexpected Ether transfers can be found here: https://scsfg.io/hackers/unexpected-ether/</p> <p>Forcing a smart contract to hold an Ether balance can influence its internal accounting and security assumptions. There are multiple ways a smart contract can receive Ether. The hierarchy is as follows:</p> <ol> <li>Check whether a payable external <code>receive</code> function is defined.</li> <li>If not, check whether a payable external <code>fallback</code> function is defined.</li> <li>Revert.</li> </ol> <p>The precedence of each function is explained in this great graphic from the Solidity by Example article:</p> <pre><code>Which function is called, fallback() or receive()?\n\n           send Ether\n               |\n         msg.data is empty?\n              / \\\n            yes  no\n            /     \\\nreceive() exists?  fallback()\n         /   \\\n        yes   no\n        /      \\\n    receive()   fallback()\n</code></pre> <p>Consider the following example:</p> <pre><code>pragma solidity ^0.8.13;\n\ncontract Vulnerable {\n    receive() external payable {\n        revert();\n    }\n\n    function somethingBad() external {\n        require(address(this).balance &gt; 0);\n        // Do something bad\n    }\n}\n</code></pre> <p>The contract's logic seemingly disallows direct payments and prevents \"something bad\" from happening. However, calling <code>revert</code> in both <code>fallback</code> and <code>receive</code> cannot prevent the contract from receiving Ether. The following techniques can be used to force-feed Ether to a smart contract.</p>"},{"location":"attacks/force-feeding/#selfdestruct","title":"Selfdestruct","text":"<p>When the <code>SELFDESTRUCT</code> opcode is called, funds of the calling address are sent to the address on the stack, and execution is immediately halted. Since this opcode works on the EVM-level, Solidity-level functions that might block the receipt of Ether will not be executed.</p>"},{"location":"attacks/force-feeding/#pre-calculated-deployments","title":"Pre-calculated Deployments","text":"<p>Additionally, the target address of newly deployed smart contracts is generated in a deterministic fashion. The address generation can be looked up in any EVM implementation, such as the py-evm reference implementation by the Ethereum Foundation:</p> <pre><code>def generate_contract_address(address: Address, nonce: int) -&gt; Address:\n    return force_bytes_to_address(keccak(rlp.encode([address, nonce])))\n</code></pre> <p>An attacker can send funds to this address before the deployment has happened. This is also illustrated by this 2017 Underhanded Solidity Contest submission.</p>"},{"location":"attacks/force-feeding/#block-rewards-and-coinbase","title":"Block Rewards and Coinbase","text":"<p>Depending on the attacker's capabilities, they can also start proof-of-work mining. By setting the target address to their <code>coinbase</code>, block rewards will be added to its balance. As this is yet another EVM-level capability, checks performed by Solidity are ineffective.</p>"},{"location":"attacks/force-feeding/#solution","title":"Solution","text":"<p>The above effects illustrate that relying on exact comparisons to the contract's Ether balance is unreliable. The smart contract's business logic must consider that the actual balance associated with it can be higher than the internal accounting's value.</p> <p>In general, we strongly advise against using the contract's balance as a guard.</p> <p>More information can be found in SWC-132.</p>"},{"location":"attacks/frontrunning/","title":"Frontrunning","text":"<p>Tip</p> <p>Thank you for visiting the Smart Contract Security Best Practices. Please note that this resource is no longer actively maintained. Instead, we recommend visiting the Smart Contract Security Field Guide. The Field Guide is regularly updated and curated by the same security engineer who previously contributed to the Best Practices guide.</p> <p>The resource on frontrunning attacks can be found here: https://scsfg.io/hackers/frontrunning/</p> <p>Since all transactions are visible in the mempool for a short while before being executed, observers of the network can see and react to an action before it is included in a block. An example of how this can be exploited is with a decentralized exchange where a buy order transaction can be seen, and second order can be broadcast and executed before the first transaction is included. Protecting against this is difficult, as it would come down to the specific contract itself.</p> <p>Front-running, coined originally for traditional financial markets, is the race to order the chaos to the winner's benefit. In financial markets, the flow of information gave birth to intermediaries that could simply profit by being the first to know and react to some information. These attacks mostly had been within stock market deals and early domain registries, such as whois gateways.</p> <p>front-run\u00b7ning (/\u02ccfr\u0259nt\u02c8r\u0259niNG/)</p> <p>noun: front-running;</p> <ol> <li> <p>STOCK MARKET</p> <p>the practice by market makers of dealing on advance information provided by their brokers and investment analysts, before their clients have been given the information. </p> </li> </ol>"},{"location":"attacks/frontrunning/#taxonomy","title":"Taxonomy","text":"<p>By defining a taxonomy and differentiating each group from another, we can make it easier to discuss the problem and find solutions for each group.</p> <p>We define the following categories of front-running attacks:</p> <ol> <li>Displacement</li> <li>Insertion</li> <li>Suppression</li> </ol>"},{"location":"attacks/frontrunning/#displacement","title":"Displacement","text":"<p>In the first type of attack, a displacement attack, it is not important for Alice\u2019s (User) function call to run after Mallory (Adversary) runs her function. Alice\u2019s can be orphaned or run with no meaningful effect. Examples of displacement include:</p> <ul> <li>Alice trying to register a domain name and Mallory registering it first;</li> <li>Alice trying to submit a bug to receive a bounty and Mallory stealing it and submitting it first;</li> <li>Alice trying to submit a bid in an auction and Mallory copying it.</li> </ul> <p>This attack is commonly performed by increasing the <code>gasPrice</code> higher than network average, often by a multiplier of 10 or more.</p>"},{"location":"attacks/frontrunning/#insertion","title":"Insertion","text":"<p>For this type of attack, it is important to the adversary that the original function call runs after her transaction. In an insertion attack, after Mallory runs her function, the state of the contract is changed and she needs Alice\u2019s original function to run on this modified state. For example, if Alice places a purchase order on a blockchain asset at a higher price than the best offer, Mallory will insert two transactions: she will purchase at the best offer price and then offer the same asset for sale at Alice\u2019s slightly higher purchase price. If Alice\u2019s transaction is then run after, Mallory will profit on the price difference without having to hold the asset.</p> <p>As with displacement attacks, this is usually done by outbidding Alice's transaction in the gas price auction.</p> <p>Transaction Order Dependence</p> <p>Transaction Order Dependence is equivalent to race condition in smart contracts. An example, if one function sets the reward percentage, and the withdraw function uses that percentage; then withdraw transaction can be front-run by a change reward function call, which impacts the amount that will be withdrawn eventually.</p> <p>See SWC-114</p>"},{"location":"attacks/frontrunning/#suppression","title":"Suppression","text":"<p>In a suppression attack, a.k.a Block Stuffing attacks, after Mallory runs her function, she tries to delay Alice from running her function.</p> <p>This was the case with the first winner of the \"Fomo3d\" game and some other on-chain hacks. The attacker sent multiple transactions with a high <code>gasPrice</code> and <code>gasLimit</code> to custom smart contracts that assert (or use other means) to consume all the gas and fill up the block's <code>gasLimit</code>.</p> <p>Variants</p> <p>Each of these attacks has two variants, asymmetric and bulk.</p> <p>In some cases, Alice and Mallory are performing different operations. For example, Alice is trying to cancel an offer, and Mallory is trying to fulfill it first. We call this asymmetric displacement. In other cases, Mallory is trying to run a large set of functions: for example, Alice and others are trying to buy a limited set of shares offered by a firm on a blockchain. We call this bulk displacement.</p>"},{"location":"attacks/frontrunning/#mitigations","title":"Mitigations","text":"<p>Front-running is a pervasive issue on public blockchains such as Ethereum.</p> <p>The best remediation is to remove the benefit of front-running in your application, mainly by removing the importance of transaction ordering or time. For example, in markets, it would be better to implement batch auctions (this also protects against high-frequency trading concerns). Another way is to use a pre-commit scheme (\u201cI\u2019m going to submit the details later\u201d). A third option is to mitigate the cost of front-running by specifying a maximum or minimum acceptable price range on a trade, thereby limiting price slippage.</p> <p>Transaction Ordering: Go-Ethereum (Geth) nodes, order the transactions based on their <code>gasPrice</code> and address nonce. This, however, results in a gas auction between participants in the network to get included in the block currently being mined.</p> <p>Confidentiality: Another approach is to limit the visibility of the transactions, this can be done using a \"commit and reveal\" scheme.</p> <p>A simple implementation is to store the keccak256 hash of the data in the first transaction, then reveal the data and verify it against the hash in the second transaction. However note that the transaction itself leaks the intention and possibly the value of the collateralization. There are enhanced commit and reveal schemes that are more secure, however require more transactions to function, e.g. submarine sends.</p>"},{"location":"attacks/griefing/","title":"Griefing","text":"<p>Tip</p> <p>Thank you for visiting the Smart Contract Security Best Practices. Please note that this resource is no longer actively maintained. Instead, we recommend visiting the Smart Contract Security Field Guide. The Field Guide is regularly updated and curated by the same security engineer who previously contributed to the Best Practices guide.</p> <p>The resource on griefing attacks can be found here: https://scsfg.io/hackers/griefing/</p> <p>This attack may be possible on a contract which accepts generic data and uses it to make a call another contract (a 'sub-call') via the low level <code>address.call()</code> function, as is often the case with multisignature and transaction relayer contracts.</p> <p>If the call fails, the contract has two options:</p> <ol> <li>revert the whole transaction</li> <li>continue execution.</li> </ol> <p>Take the following example of a simplified <code>Relayer</code> contract which continues execution regardless of the outcome of the subcall:</p> <pre><code>contract Relayer {\n    mapping (bytes =&gt; bool) executed;\n\n    function relay(bytes _data) public {\n        // replay protection; do not call the same transaction twice\n        require(executed[_data] == 0, \"Duplicate call\");\n        executed[_data] = true;\n        innerContract.call(bytes4(keccak256(\"execute(bytes)\")), _data);\n    }\n}\n</code></pre> <p>This contract allows transaction relaying. Someone who wants to make a transaction but can't execute it by himself (e.g. due to the lack of ether to pay for gas) can sign data that he wants to pass and transfer the data with his signature over any medium. A third party \"forwarder\" can then submit this transaction to the network on behalf of the user.</p> <p>If given just the right amount of gas, the <code>Relayer</code> would complete execution recording the <code>_data</code>argument in the <code>executed</code> mapping, but the subcall would fail because it received insufficient gas to complete execution.</p> <p>Note</p> <p>When a contract makes a sub-call to another contract, the EVM limits the gas forwarded to to 63/64 of the remaining gas,</p> <p>An attacker can use this to censor transactions, causing them to fail by sending them with a low amount of gas. This attack is a form of \"griefing\": It doesn't directly benefit the attacker, but causes grief for the victim. A dedicated attacker, willing to consistently spend a small amount of gas could theoretically censor all transactions this way, if they were the first to submit them to <code>Relayer</code>.</p> <p>One way to address this is to implement logic requiring forwarders to provide enough gas to finish the subcall. If the miner tried to conduct the attack in this scenario, the <code>require</code> statement would fail and the inner call would revert. A user can specify a minimum gasLimit along with the other data (in this example, typically the <code>_gasLimit</code> value would be verified by a signature, but that is omitted for simplicity in this case).</p> <pre><code>// contract called by Relayer\ncontract Executor {\n    function execute(bytes _data, uint _gasLimit) {\n        require(gasleft() &gt;= _gasLimit);\n        ...\n    }\n}\n</code></pre> <p>Another solution is to permit only trusted accounts to relay the transaction.</p>"},{"location":"attacks/insecure-arithmetic/","title":"Insecure Arithmetic","text":"<p>Consider a simple token transfer:</p> <pre><code>mapping (address =&gt; uint256) public balanceOf;\n\n// INSECURE\nfunction transfer(address _to, uint256 _value) {\n    /* Check if sender has balance */\n    require(balanceOf[msg.sender] &gt;= _value);\n    /* Add and subtract new balances */\n    balanceOf[msg.sender] -= _value;\n    balanceOf[_to] += _value;\n}\n\n// SECURE\nfunction transfer(address _to, uint256 _value) {\n    /* Check if sender has balance and for overflows */\n    require(balanceOf[msg.sender] &gt;= _value &amp;&amp; balanceOf[_to] + _value &gt;= balanceOf[_to]);\n\n    /* Add and subtract new balances */\n    balanceOf[msg.sender] -= _value;\n    balanceOf[_to] += _value;\n}\n</code></pre> <p>If a balance reaches the maximum uint value (2^256) it will circle back to zero which checks for the condition. This may or may not be relevant, depending on the implementation. Think about whether or not the <code>uint</code> value has an opportunity to approach such a large number. Think about how the <code>uint</code> variable changes state, and who has authority to make such changes. If any user can call functions which update the <code>uint</code> value, it's more vulnerable to attack. If only an admin has access to change the variable's state, you might be safe. If a user can increment by only 1 at a time, you are probably also safe because there is no feasible way to reach this limit.</p> <p>The same is true for underflow. If a uint is made to be less than zero, it will cause an underflow and get set to its maximum value.</p> <p>Be careful with the smaller data-types like uint8, uint16, uint24...etc: they can even more easily hit their maximum value.</p> <p>Warning</p> <p>Be aware there are around 20 cases for overflow and underflow.</p> <p>One simple solution to mitigate the common mistakes for overflow and underflow is to use <code>SafeMath.sol</code> library for arithmetic functions. Solidity automatically reverts on integer overflow and underflow, as of version 0.8.0.</p> <p>See SWC-101</p>"},{"location":"attacks/more/","title":"More","text":"<p>The Smart Contract Weakness Classification Registry offers a complete and up-to-date catalogue of known smart contract vulnerabilities and anti-patterns along with real-world examples. Browsing the registry is a good way of keeping up-to-date with the latest attacks. It has been proposed formally in EIP-1470 and is loosely aligned with the Common Weakness Enumeration (CWE).</p> <p>Additionally, the Smart Contract Security Verification Standard (SCSVS) contains a checklist-style collection of vital security properties aimed at standardizing the security of smart contracts for developers, architects, security reviewers and vendors.</p>"},{"location":"attacks/oracle-manipulation/","title":"Oracle Manipulation","text":"<p>Tip</p> <p>Thank you for visiting the Smart Contract Security Best Practices. Please note that this resource is no longer actively maintained. Instead, we recommend visiting the Smart Contract Security Field Guide. The Field Guide is regularly updated and curated by the same security engineer who previously contributed to the Best Practices guide.</p> <p>The resource on oracle manipulation attacks can be found here: https://scsfg.io/hackers/oracle-manipulation/</p> <p>Protocols that rely on external data as inputs (from what's known as an oracle) automatically execute even if the data is incorrect, due to the nature of smart contracts. If a protocol relies on an oracle that is hacked, deprecated, or has malicious intent, all processes that depend on the oracle can now operate with disastrous effects.</p> <p>For example:</p> <ol> <li>Protocol gets price from single Uniswap pool</li> <li>Malicious actor drains one side of the pool with a large transaction</li> <li>Uniswap pool starts responding with a price more than 100x what it should be</li> <li>Protocol operates as if that were the actual price, giving the manipulator a better price</li> </ol> <p>We've seen examples where this will liquidate positions, allow insane arbitrage, ruin DEX positions, and more.</p>"},{"location":"attacks/oracle-manipulation/#oracle-manipulation-solutions","title":"Oracle Manipulation Solutions","text":"<p>The easiest way to solve this is to use decentralized oracles such as:</p> <ul> <li>Chainlink is the leading decentralized oracle provider, and the Chainlink network can be leveraged to bring decentralized data on-chain.</li> <li>Tellor is an oracle that provides censorship resistant data, secured by crypto-economic incentives, that ensure data can be provided by anyone, anytime, and checked by everyone.</li> <li>Witnet leverages state-of-the-art cryptographic and economic techniques to provide your smart contracts with secure data input.</li> </ul> <p>Using a median of multiple oracles provides heighten security since it is harder and more expensive to attack multiple oracles than one and it ensures that your smart contract gets the data it needs even if one oracle or API call fails. </p> <p>Another common solution is to use a time-weighted average price feed, so that price is averaged out over <code>X</code> time periods and multiple sources. Not only does this prevent oracle manipulation, but it also reduces the chance you can be front-run, as an order executed right before yours won't have as drastic an impact on price. However, always keep in mind that low liquidity assets are generally easier/cheaper to manipulate, even for a period of time. One tool that gathers Uniswap price feeds every thirty minutes is Keep3r. If you're looking to build a custom solution, Uniswap provides a sliding window example.</p>"},{"location":"attacks/reentrancy/","title":"Reentrancy","text":"<p>Tip</p> <p>Thank you for visiting the Smart Contract Security Best Practices. Please note that this resource is no longer actively maintained. Instead, we recommend visiting the Smart Contract Security Field Guide. The Field Guide is regularly updated and curated by the same security engineer who previously contributed to the Best Practices guide.</p> <p>The resource on reentrancy can be found here: https://scsfg.io/hackers/reentrancy/</p> <p>One of the major dangers of calling external contracts is that they can take over the control flow, and make changes to your data that the calling function wasn't expecting. This class of bugs can take many forms, and both of the major bugs that led to the DAO's collapse were bugs of this sort.</p>"},{"location":"attacks/reentrancy/#reentrancy-on-a-single-function","title":"Reentrancy on a Single Function","text":"<p>The first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways.</p> <pre><code>// INSECURE\nmapping (address =&gt; uint) private userBalances;\n\nfunction withdrawBalance() public {\n    uint amountToWithdraw = userBalances[msg.sender];\n    (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call withdrawBalance again\n    require(success);\n    userBalances[msg.sender] = 0;\n}\n</code></pre> <p>Since the user's balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed and will withdraw the balance over and over again.</p> <p>Factoid</p> <p>A DAO is a Decentralized Autonomous Organization. Its goal is to codify the rules and decision-making apparatus of an organization, eliminating the need for documents and people in governing, creating a structure with decentralized control.</p> <pre><code>On June 17th 2016, [The DAO](https://www.coindesk.com/understanding-dao-hack-journalists) was hacked and 3.6 million Ether ($50 Million) were stolen using the first reentrancy attack.\n\nEthereum Foundation issued a critical update to rollback the hack. This resulted in Ethereum being forked into Ethereum Classic and Ethereum.\n</code></pre> <p>In the example given, the best way to prevent this attack is to make sure you don't call an external function until you've done all the internal work you need to do:</p> <pre><code>mapping (address =&gt; uint) private userBalances;\n\nfunction withdrawBalance() public {\n    uint amountToWithdraw = userBalances[msg.sender];\n    userBalances[msg.sender] = 0;\n    (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // The user's balance is already 0, so future invocations won't withdraw anything\n    require(success);\n}\n</code></pre> <p>Note that if you had another function which called <code>withdrawBalance()</code>, it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions.</p>"},{"location":"attacks/reentrancy/#cross-function-reentrancy","title":"Cross-function Reentrancy","text":"<p>An attacker may also be able to do a similar attack using two different functions that share the same state.</p> <pre><code>// INSECURE\nmapping (address =&gt; uint) private userBalances;\n\nfunction transfer(address to, uint amount) {\n    if (userBalances[msg.sender] &gt;= amount) {\n       userBalances[to] += amount;\n       userBalances[msg.sender] -= amount;\n    }\n}\n\nfunction withdrawBalance() public {\n    uint amountToWithdraw = userBalances[msg.sender];\n    (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call transfer()\n    require(success);\n    userBalances[msg.sender] = 0;\n}\n</code></pre> <p>In this case, the attacker calls <code>transfer()</code> when their code is executed on the external call in <code>withdrawBalance</code>. Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack.</p> <p>The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.</p>"},{"location":"attacks/reentrancy/#pitfalls-in-reentrancy-solutions","title":"Pitfalls in Reentrancy Solutions","text":"<p>Since reentrancy can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentrancy with a single function will not be sufficient.</p> <p>Instead, we have recommended finishing all internal work (ie. state changes) first, and only then calling the external function. This rule, if followed carefully, will allow you to avoid vulnerabilities due to reentrancy. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure:</p> <pre><code>// INSECURE\nmapping (address =&gt; uint) private userBalances;\nmapping (address =&gt; bool) private claimedBonus;\nmapping (address =&gt; uint) private rewardsForA;\n\nfunction withdrawReward(address recipient) public {\n    uint amountToWithdraw = rewardsForA[recipient];\n    rewardsForA[recipient] = 0;\n    (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n    require(success);\n}\n\nfunction getFirstWithdrawalBonus(address recipient) public {\n    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n    rewardsForA[recipient] += 100;\n    withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n    claimedBonus[recipient] = true;\n}\n</code></pre> <p>Even though <code>getFirstWithdrawalBonus()</code> doesn't directly call an external contract, the call in <code>withdrawReward()</code> is enough to make it vulnerable to a reentrancy. You therefore need to treat <code>withdrawReward()</code> as if it were also untrusted.</p> <pre><code>mapping (address =&gt; uint) private userBalances;\nmapping (address =&gt; bool) private claimedBonus;\nmapping (address =&gt; uint) private rewardsForA;\n\nfunction untrustedWithdrawReward(address recipient) public {\n    uint amountToWithdraw = rewardsForA[recipient];\n    rewardsForA[recipient] = 0;\n    (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n    require(success);\n}\n\nfunction untrustedGetFirstWithdrawalBonus(address recipient) public {\n    require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n    claimedBonus[recipient] = true;\n    rewardsForA[recipient] += 100;\n    untrustedWithdrawReward(recipient); // claimedBonus has been set to true, so reentry is impossible\n}\n</code></pre> <p>In addition to the fix making reentry impossible, untrusted functions have been marked. This same pattern repeats at every level: since <code>untrustedGetFirstWithdrawalBonus()</code> calls <code>untrustedWithdrawReward()</code>, which calls an external contract, you must also treat <code>untrustedGetFirstWithdrawalBonus()</code> as insecure.</p> <p>Another solution often suggested is a mutex. This allows you to \"lock\" some state so it can only be changed by the owner of the lock. A simple example might look like this:</p> <pre><code>// Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state\nmapping (address =&gt; uint) private balances;\nbool private lockBalances;\n\nfunction deposit() payable public returns (bool) {\n    require(!lockBalances);\n    lockBalances = true;\n    balances[msg.sender] += msg.value;\n    lockBalances = false;\n    return true;\n}\n\nfunction withdraw(uint amount) payable public returns (bool) {\n    require(!lockBalances &amp;&amp; amount &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);\n    lockBalances = true;\n\n    (bool success, ) = msg.sender.call(amount)(\"\");\n\n    if (success) { // Normally insecure, but the mutex saves it\n      balances[msg.sender] -= amount;\n    }\n\n    lockBalances = false;\n    return true;\n}\n</code></pre> <p>If the user tries to call <code>withdraw()</code> again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure:</p> <pre><code>// INSECURE\ncontract StateHolder {\n    uint private n;\n    address private lockHolder;\n\n    function getLock() {\n        require(lockHolder == address(0));\n        lockHolder = msg.sender;\n    }\n\n    function releaseLock() {\n        require(msg.sender == lockHolder);\n        lockHolder = address(0);\n    }\n\n    function set(uint newState) {\n        require(msg.sender == lockHolder);\n        n = newState;\n    }\n}\n</code></pre> <p>An attacker can call <code>getLock()</code>, and then never call <code>releaseLock()</code>. If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against reentrancy, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.)</p> <p>See SWC-107</p> <p>Above were examples of reentrancy involving the attacker executing malicious code within a single transaction. The following are a different type of attack inherent to Blockchains: the fact that the order of transactions themselves (e.g. within a block) is easily subject to manipulation.</p>"},{"location":"attacks/timestamp-dependence/","title":"Timestamp Dependence","text":"<p>Be aware that the timestamp of the block can be manipulated by the miner, and all direct and indirect uses of the timestamp should be considered.</p> <p>Note</p> <p>See the Recommendations section for design considerations related to Timestamp Dependence.</p> <p>See SWC-116</p>"},{"location":"development-recommendations/","title":"Index","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>The development recommendations are split into six categories.</p> Category Description General Guiding principles that should be kept in mind during development. Precautions Principles that prevent attacks in general or avoid excessive damage in the worst case scenario. Solidity-specific Helpful tips when building smart contracts in Solidity - including interesting quirks. Token-specifc Recommendations to honour when dealing with or implementing tokens Documentation Guidelines on how to properly document smart contracts and the processes surrounding them. Deprecated Vulnerabilities that were applicable in the past but can be reasonably excluded nowadays."},{"location":"development-recommendations/deprecated/constructor-naming/","title":"Constructor Naming","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p>"},{"location":"development-recommendations/deprecated/division-by-zero/","title":"Division by Zero","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Prior to version 0.4, Solidity returns zero and does not <code>throw</code> an exception when a number is divided by zero. Ensure you're running at least version 0.4.</p>"},{"location":"development-recommendations/deprecated/functions-and-events/","title":"Functions and Events","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p>"},{"location":"development-recommendations/deprecated/functions-and-events/#differentiate-functions-and-events-solidity-0421","title":"Differentiate functions and events (Solidity \\&lt; 0.4.21)","text":"<p>Favor capitalization and a prefix in front of events (we suggest Log), to prevent the risk of confusion between functions and events. For functions, always start with a lowercase letter, except for the constructor.</p> <pre><code>// bad\nevent Transfer() {}\nfunction transfer() {}\n\n// good\nevent LogTransfer() {}\nfunction transfer() external {}\n</code></pre> <p>Note</p> <p>In v0.4.21 Solidity introduced the <code>emit</code> keyword to indicate an event <code>emit EventName();</code>. As of 0.5.0, it is required.</p>"},{"location":"development-recommendations/documentation/contact/","title":"Contact","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <ul> <li>Who to contact with issues</li> <li>Names of programmers and/or other important parties</li> <li>Chat room where questions can be asked</li> </ul>"},{"location":"development-recommendations/documentation/general/","title":"General","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>When launching a contract that will have substantial funds or is required to be mission critical, it is important to include proper documentation.</p>"},{"location":"development-recommendations/documentation/history/","title":"History","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <ul> <li>Testing (including usage stats, discovered bugs, length of testing)</li> <li>People who have reviewed code (and their key feedback)</li> </ul>"},{"location":"development-recommendations/documentation/known-issues/","title":"Known Issues","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <ul> <li>Key risks with contract</li> <li>e.g., You can lose all your money, hacker can vote for certain outcomes</li> <li>All known bugs/limitations</li> <li>Potential attacks and mitigants</li> <li>Potential conflicts of interest (e.g., will be using yourself, like Slock.it did with the DAO)</li> </ul>"},{"location":"development-recommendations/documentation/procedures/","title":"Procedures","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <ul> <li>Action plan in case a bug is discovered (e.g., emergency options, public notification process,   etc.)</li> <li>Wind down process if something goes wrong (e.g., funders will get percentage of your balance   before attack, from remaining funds)</li> <li>Responsible disclosure policy (e.g., where to report bugs found, the rules of any bug bounty   program)</li> <li>Recourse in case of failure (e.g., insurance, penalty fund, no recourse)</li> </ul>"},{"location":"development-recommendations/documentation/specification/","title":"Specification","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <ul> <li>Specs, diagrams, state machines, models, and other documentation that helps auditors, reviewers,   and the community understand what the system is intended to do.</li> <li>Many bugs can be found just from the specifications, and they are the least costly to fix.</li> <li>Rollout plans that include details listed here, and   target dates.</li> </ul>"},{"location":"development-recommendations/documentation/status/","title":"Status","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <ul> <li>Where current code is deployed</li> <li>Compiler version, flags used, and steps for verifying the deployed bytecode matches the source   code</li> <li>Compiler versions and flags that will be used for the different phases of rollout.</li> <li>Current status of deployed code (including outstanding issues, performance stats, etc.)</li> </ul>"},{"location":"development-recommendations/general/external-calls/","title":"External Calls","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p>"},{"location":"development-recommendations/general/external-calls/#use-caution-when-making-external-calls","title":"Use caution when making external calls","text":"<p>Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon. As such, every external call should be treated as a potential security risk. When it is not possible, or undesirable to remove external calls, use the recommendations in the rest of this section to minimize the danger.</p>"},{"location":"development-recommendations/general/external-calls/#mark-untrusted-contracts","title":"Mark untrusted contracts","text":"<p>When interacting with external contracts, name your variables, methods, and contract interfaces in a way that makes it clear that interacting with them is potentially unsafe. This applies to your own functions that call external contracts.</p> <pre><code>// bad\nBank.withdraw(100); // Unclear whether trusted or untrusted\n\nfunction makeWithdrawal(uint amount) { // Isn't clear that this function is potentially unsafe\n    Bank.withdraw(amount);\n}\n\n// good\nUntrustedBank.withdraw(100); // untrusted external call\nTrustedBank.withdraw(100); // external but trusted bank contract maintained by XYZ Corp\n\nfunction makeUntrustedWithdrawal(uint amount) {\n    UntrustedBank.withdraw(amount);\n}\n</code></pre>"},{"location":"development-recommendations/general/external-calls/#avoid-state-changes-after-external-calls","title":"Avoid state changes after external calls","text":"<p>Whether using raw calls (of the form <code>someAddress.call()</code>) or contract calls (of the form <code>ExternalContract.someMethod()</code>), assume that malicious code might execute. Even if <code>ExternalContract</code> is not malicious, malicious code can be executed by any contracts it calls.</p> <p>One particular danger is malicious code may hijack the control flow, leading to vulnerabilities due to reentrancy. (See Reentrancy for a fuller discussion of this problem).</p> <p>If you are making a call to an untrusted external contract, avoid state changes after the call. This pattern is also sometimes known as the checks-effects-interactions pattern.</p> <p>See SWC-107</p>"},{"location":"development-recommendations/general/external-calls/#dont-use-transfer-or-send","title":"Don't use <code>transfer()</code> or <code>send()</code>.","text":"<p><code>.transfer()</code> and <code>.send()</code> forward exactly 2,300 gas to the recipient. The goal of this hardcoded gas stipend was to prevent reentrancy vulnerabilities, but this only makes sense under the assumption that gas costs are constant. Recently EIP 1884 was included in the Istanbul hard fork. One of the changes included in EIP 1884 is an increase to the gas cost of the <code>SLOAD</code> operation, causing a contract's fallback function to cost more than 2300 gas.</p> <p>It's recommended to stop using <code>.transfer()</code> and <code>.send()</code> and instead use <code>.call()</code>.</p> <pre><code>// bad\ncontract Vulnerable {\n    function withdraw(uint256 amount) external {\n        // This forwards 2300 gas, which may not be enough if the recipient\n        // is a contract and gas costs change.\n        msg.sender.transfer(amount);\n    }\n}\n\n// good\ncontract Fixed {\n    function withdraw(uint256 amount) external {\n        // This forwards all available gas. Be sure to check the return value!\n        (bool success, ) = msg.sender.call.value(amount)(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n</code></pre> <p>Note that <code>.call()</code> does nothing to mitigate reentrancy attacks, so other precautions must be taken. To prevent reentrancy attacks, it is recommended that you use the checks-effects-interactions pattern.</p>"},{"location":"development-recommendations/general/external-calls/#handle-errors-in-external-calls","title":"Handle errors in external calls","text":"<p>Solidity offers low-level call methods that work on raw addresses: <code>address.call()</code>, <code>address.callcode()</code>, <code>address.delegatecall()</code>, and <code>address.send()</code>. These low-level methods never throw an exception, but will return <code>false</code> if the call encounters an exception. On the other hand, contract calls (e.g., <code>ExternalContract.doSomething()</code>) will automatically propagate a throw (for example, <code>ExternalContract.doSomething()</code> will also <code>throw</code> if <code>doSomething()</code> throws).</p> <p>If you choose to use the low-level call methods, make sure to handle the possibility that the call will fail, by checking the return value.</p> <pre><code>// bad\nsomeAddress.send(55);\nsomeAddress.call.value(55)(\"\"); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result\nsomeAddress.call.value(100)(bytes4(sha3(\"deposit()\"))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted\n\n// good\n(bool success, ) = someAddress.call.value(55)(\"\");\nif(!success) {\n    // handle failure code\n}\n\nExternalContract(someAddress).deposit.value(100)();\n</code></pre> <p>See SWC-104</p>"},{"location":"development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls","title":"Favor pull over push for external calls","text":"<p>External calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is often better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of problems with the gas limit.) Avoid combining multiple ether transfers in a single transaction.</p> <pre><code>// bad\ncontract auction {\n    address highestBidder;\n    uint highestBid;\n\n    function bid() payable {\n        require(msg.value &gt;= highestBid);\n\n        if (highestBidder != address(0)) {\n            (bool success, ) = highestBidder.call.value(highestBid)(\"\");\n            require(success); // if this call consistently fails, no one else can bid\n        }\n\n       highestBidder = msg.sender;\n       highestBid = msg.value;\n    }\n}\n\n// good\ncontract auction {\n    address highestBidder;\n    uint highestBid;\n    mapping(address =&gt; uint) refunds;\n\n    function bid() payable external {\n        require(msg.value &gt;= highestBid);\n\n        if (highestBidder != address(0)) {\n            refunds[highestBidder] += highestBid; // record the refund that this user can claim\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdrawRefund() external {\n        uint refund = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        (bool success, ) = msg.sender.call.value(refund)(\"\");\n        require(success);\n    }\n}\n</code></pre> <p>See SWC-128</p>"},{"location":"development-recommendations/general/external-calls/#dont-delegatecall-to-untrusted-code","title":"Don't delegatecall to untrusted code","text":"<p>The <code>delegatecall</code> function is used to call functions from other contracts as if they belong to the caller contract. Thus the callee may change the state of the calling address. This may be insecure. An example below shows how using <code>delegatecall</code> can lead to the destruction of the contract and loss of its balance.</p> <pre><code>contract Destructor\n{\n    function doWork() external\n    {\n        selfdestruct(0);\n    }\n}\n\ncontract Worker\n{\n    function doWork(address _internalWorker) public\n    {\n        // unsafe\n        _internalWorker.delegatecall(bytes4(keccak256(\"doWork()\")));\n    }\n}\n</code></pre> <p>If <code>Worker.doWork()</code> is called with the address of the deployed <code>Destructor</code> contract as an argument, the <code>Worker</code> contract will self-destruct. Delegate execution only to trusted contracts, and never to a user supplied address.</p> <p>Warning</p> <p>Don't assume contracts are created with zero balance.  An attacker can send ether to the address of a contract before it is created so contracts should not assume that their initial state contains a zero balance. See issue 61 for more details.</p> <p>See SWC-112</p>"},{"location":"development-recommendations/general/force-feeding/","title":"Force-feeding Ether","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Beware of coding an invariant that strictly checks the balance of a contract.</p> <p>An attacker can forcibly send ether to any account and this cannot be prevented (not even with a fallback function that does a <code>revert()</code>).</p> <p>The attacker can do this by creating a contract, funding it with 1 wei, and invoking <code>selfdestruct(victimAddress)</code>. No code is invoked in <code>victimAddress</code>, so it cannot be prevented. This is also true for block reward which is sent to the address of the miner, which can be any arbitrary address.</p> <p>Also, since contract addresses can be precomputed, ether can be sent to an address before the contract is deployed.</p> <p>See SWC-132</p>"},{"location":"development-recommendations/general/negative-int/","title":"Negation of Signed Integers","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Solidity provides several types to work with signed integers. Like in most programming languages, in Solidity a signed integer with <code>N</code> bits can represent values from <code>-2^(N-1)</code> to <code>2^(N-1)-1</code>. This means that there is no positive equivalent for the <code>MIN_INT</code>. Negation is implemented as finding the two's complement of a number, so the negation of the most negative number will result in the same number.</p> <p>This is true for all signed integer types in Solidity (<code>int8</code>, <code>int16</code>, ..., <code>int256</code>).</p> <pre><code>contract Negation {\n    function negate8(int8 _i) public pure returns(int8) {\n        return -_i;\n    }\n\n    function negate16(int16 _i) public pure returns(int16) {\n        return -_i;\n    }\n\n    int8 public a = negate8(-128); // -128\n    int16 public b = negate16(-128); // 128\n    int16 public c = negate16(-32768); // -32768\n}\n</code></pre> <p>One way to handle this is to check the value of a variable before negation and throw if it's equal to the <code>MIN_INT</code>. Another option is to make sure that the most negative number will never be achieved by using a type with a higher capacity (e.g. <code>int32</code> instead of <code>int16</code>).</p> <p>A similar issue with <code>int</code> types occurs when <code>MIN_INT</code> is multiplied or divided by <code>-1</code>.</p>"},{"location":"development-recommendations/general/participants/","title":"Unreliable Participants","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Do not make refund or claim processes dependent on a specific party performing a particular action with no other way of getting the funds out. For example, in a rock-paper-scissors game, one common mistake is to not make a payout until both players submit their moves; however, a malicious player can \"grief\" the other by simply never submitting their move - in fact, if a player sees the other player's revealed move and determines that they lost, they have no reason to submit their own move at all. This issue may also arise in the context of state channel settlement. When such situations are an issue, (1) provide a way of circumventing non-participating participants, perhaps through a time limit, and (2) consider adding economic incentive for participants to submit information in all of the situations in which they are supposed to do so.</p>"},{"location":"development-recommendations/general/public-data/","title":"Public on-chain Data","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Many applications require submitted data to be private up until some point in time in order to work. Games (eg. on-chain rock-paper-scissors) and auction mechanisms (eg. sealed-bid Vickrey auctions) are two major categories of examples. If you are building an application where privacy is an issue, make sure you avoid requiring users to publish information too early. The best strategy is to use commitment schemes with separate phases: first commit using the hash of the values and in a later phase revealing the values.</p> <p>However, care must be taken to ensure that the hashed value stored isn't recognisable (and thus, de-mappable), as this would defeat the second purpose of hashing - preventing the reveal of such values. Here's an example:</p> <p>Say a smart contract allows 2 players to play rock-paper-scissors, and uses this commit-reveal scheme - both players have to send a hash of their move before either of them sends the last (game ending) transaction. Here's what the keccak256 hash of <code>rock</code> is: <code>10977e4d68108d418408bc9310b60fc6d0a750c63ccef42cfb0ead23ab73d102</code>. If you were playing, and you saw your opponent commiting this, wouldn't this tell you exactly what move your opponent has committed to? A safer implementation would be to hash not just the name of the move, but also, say, a user chosen salt. That would make the resulting salt non-recognisable.</p> <p>Examples:</p> <ul> <li>In rock paper scissors, require both players to submit a hash of their intended move first, then   require both players to submit their move; if the submitted move does not match the hash throw it   out.</li> <li>In an auction, require players to submit a hash of their bid value in an initial phase (along   with a deposit greater than their bid value), and then submit their auction bid value in the   second phase.</li> <li>When developing an application that depends on a random number generator, the order should always   be (1) players submit moves, (2) random number generated, (3) players paid out. The method   by which random numbers are generated is itself an area of active research; current best-in-class   solutions include Bitcoin block headers (verified through http://btcrelay.org),   hash-commit-reveal schemes (ie. one party generates a number, publishes its hash to \"commit\" to   the value, and then reveals the value later) and RANDAO. As   Ethereum is a deterministic protocol, no variable within the protocol could be used as an   unpredictable random number. Also, be aware that miners are in some extent in control of the   <code>block.blockhash()</code>   value.</li> </ul>"},{"location":"development-recommendations/precautions/circuit-breakers/","title":"Circuit Breakers","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Circuit breakers stop execution if certain conditions are met, and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a bug is discovered, and the only action now active is a withdrawal. You can either give certain trusted parties the ability to trigger the circuit breaker or else have programmatic rules that automatically trigger the certain breaker when certain conditions are met.</p> <p>Example:</p> <pre><code>bool private stopped = false;\naddress private owner;\n\nmodifier isAdmin() {\n    require(msg.sender == owner);\n    _;\n}\n\nfunction toggleContractActive() isAdmin public {\n    // You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users\n    stopped = !stopped;\n}\n\nmodifier stopInEmergency { if (!stopped) _; }\nmodifier onlyInEmergency { if (stopped) _; }\n\nfunction deposit() stopInEmergency public {\n    // some code\n}\n\nfunction withdraw() onlyInEmergency public {\n    // some code\n}\n</code></pre>"},{"location":"development-recommendations/precautions/deployment/","title":"Deployment","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Contracts should have a substantial and prolonged testing period - before substantial money is put at risk.</p> <p>At minimum, you should:</p> <ul> <li>Have a full test suite with 100% test coverage (or close to it)</li> <li>Deploy on your own testnet</li> <li>Deploy on the public testnet with substantial testing and bug bounties</li> <li>Exhaustive testing should allow various players to interact with the contract at volume</li> <li>Deploy on the mainnet in beta, with limits to the amount at risk</li> </ul>"},{"location":"development-recommendations/precautions/deployment/#automatic-deprecation","title":"Automatic Deprecation","text":"<p>During testing, you can force an automatic deprecation by preventing any actions, after a certain time period. For example, an alpha contract may work for several weeks and then automatically shut down all actions, except for the final withdrawal.</p> <pre><code>modifier isActive() {\n    require(block.number &lt;= SOME_BLOCK_NUMBER);\n    _;\n}\n\nfunction deposit() public isActive {\n    // some code\n}\n\nfunction withdraw() public {\n    // some code\n}\n</code></pre>"},{"location":"development-recommendations/precautions/deployment/#restrict-amount-of-ether-per-usercontract","title":"Restrict amount of Ether per user/contract","text":"<p>In the early stages, you can restrict the amount of Ether for any user (or for the entire contract) - reducing the risk.</p>"},{"location":"development-recommendations/precautions/general/","title":"General","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>As we discussed in the General Philosophy section, it is not enough to protect yourself against the known attacks. Since the cost of failure on a blockchain can be very high, you must also adapt the way you write software, to account for that risk.</p> <p>The approach we advocate is to \"prepare for failure\". It is impossible to know in advance whether your code is secure. However, you can architect your contracts in a way that allows them to fail gracefully, and with minimal damage. This section presents a variety of techniques that will help you prepare for failure.</p> <p>Note: There's always a risk when you add a new component to your system. A badly designed fail-safe could itself become a vulnerability, as can the interaction between a number of well-designed fail-safes. Be thoughtful about each technique you use in your contracts, and consider carefully how they work together to create a robust system.</p>"},{"location":"development-recommendations/precautions/rate-limiting/","title":"Rate Limiting","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Rate limiting halts or requires approval for substantial changes. For example, a depositor may only be allowed to withdraw a certain amount or percentage of total deposits over a certain time period (e.g., max 100 ether over 1 day) - additional withdrawals in that time period may fail or require some sort of special approval. Or the rate limit could be at the contract level, with only a certain amount of tokens issued by the contract over a time period.</p> <p>Example:</p> <pre><code>uint internal period; // how many blocks before limit resets\nuint internal limit; // max ether to withdraw per period\nuint internal currentPeriodEnd; // block which the current period ends at\nuint internal currentPeriodAmount; // amount already withdrawn this period\n\nconstructor(uint _period, uint _limit) public {\n    period = _period;\n    limit = _limit;\n\n    currentPeriodEnd = block.number + period;\n}\n\nfunction withdraw(uint amount) public {\n    // Update period before proceeding\n    updatePeriod();\n\n    // Prevent overflow\n    uint totalAmount = currentPeriodAmount + amount;\n    require(totalAmount &gt;= currentPeriodAmount, 'overflow');\n\n    // Disallow withdraws that exceed current rate limit\n    require(currentPeriodAmount + amount &lt; limit, 'exceeds period limit');\n    currentPeriodAmount += amount;\n    msg.sender.transfer(amount);\n}\n\nfunction updatePeriod() internal {\n    if(currentPeriodEnd &lt; block.number) {\n        currentPeriodEnd = block.number + period;\n        currentPeriodAmount = 0;\n    }\n}\n</code></pre>"},{"location":"development-recommendations/precautions/safe-haven/","title":"Safe Haven","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Some tips for running bounty programs:</p> <ul> <li>Decide which currency bounties will be distributed in (BTC and/or ETH)</li> <li>Decide on an estimated total budget for bounty rewards</li> <li>From the budget, determine three tiers of rewards:</li> <li>smallest reward you are willing to give out</li> <li>highest reward that's usually awardable</li> <li>an extra range to be awarded in case of very severe vulnerabilities</li> <li>Determine who the bounty judges are (3 may be ideal typically)</li> <li>Lead developer should probably be one of the bounty judges</li> <li>When a bug report is received, the lead developer, with advice from judges, should evaluate the   severity of the bug</li> <li>Work at this stage should be in a private repo, and the issue filed on Github</li> <li>If it's a bug that should be fixed, in the private repo, a developer should write a test case,   which should fail and thus confirm the bug</li> <li>Developer should implement the fix and ensure the test now passes; writing additional tests as   needed</li> <li>Show the bounty hunter the fix; merge the fix back to the public repo is one way</li> <li>Determine if bounty hunter has any other feedback about the fix</li> <li>Bounty judges determine the size of the reward, based on their evaluation of both the   likelihood and impact of the bug.</li> <li>Keep bounty participants informed throughout the process, and then strive to avoid delays in   sending them their reward</li> </ul> <p>For an example of the three tiers of rewards, see Ethereum's Bounty Program:</p> <p>The value of rewards paid out will vary depending on severity of impact. Rewards for minor 'harmless' bugs start at 0.05 BTC. Major bugs, for example leading to consensus issues, will be rewarded up to 5 BTC. Much higher rewards are possible (up to 25 BTC) in case of very severe vulnerabilities.</p>"},{"location":"development-recommendations/precautions/speed-bumps/","title":"Speed Bumps","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Speed bumps slow down actions, so that if malicious actions occur, there is time to recover. For example, The DAO required 27 days between a successful request to split the DAO and the ability to do so. This ensured the funds were kept within the contract, increasing the likelihood of recovery. In the case of the DAO, there was no effective action that could be taken during the time given by the speed bump, but in combination with our other techniques, they can be quite effective.</p> <p>Example:</p> <pre><code>struct RequestedWithdrawal {\n    uint amount;\n    uint time;\n}\n\nmapping (address =&gt; uint) private balances;\nmapping (address =&gt; RequestedWithdrawal) private requestedWithdrawals;\nuint constant withdrawalWaitPeriod = 28 days; // 4 weeks\n\nfunction requestWithdrawal() public {\n    if (balances[msg.sender] &gt; 0) {\n        uint amountToWithdraw = balances[msg.sender];\n        balances[msg.sender] = 0; // for simplicity, we withdraw everything;\n        // presumably, the deposit function prevents new deposits when withdrawals are in progress\n\n        requestedWithdrawals[msg.sender] = RequestedWithdrawal({\n            amount: amountToWithdraw,\n            time: block.timestamp\n        });\n    }\n}\n\nfunction withdraw() public {\n    if(requestedWithdrawals[msg.sender].amount &gt; 0 &amp;&amp; block.timestamp &gt; requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) {\n        uint amountToWithdraw = requestedWithdrawals[msg.sender].amount;\n        requestedWithdrawals[msg.sender].amount = 0;\n\n        require(msg.sender.send(amountToWithdraw));\n    }\n}\n</code></pre>"},{"location":"development-recommendations/precautions/upgradeability/","title":"Upgradeability","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Code will need to be changed if errors are discovered or if improvements need to be made. It is no good to discover a bug, but have no way to deal with it.</p> <p>Designing an effective upgrade system for smart contracts is an area of active research, and we won't be able to cover all of the complications in this document. However, two basic approaches are most commonly used. The simpler of the two is to have a registry contract that holds the address of the latest version of the contract. A more seamless approach for contract users is to have a contract that forwards calls and data onto the latest version of the contract.</p> <p>Whatever the technique, it's important to have modularization and good separation between components, so that code changes do not break functionality, orphan data, or require substantial costs to port. In particular, it is usually beneficial to separate complex logic from your data storage, so that you do not have to recreate all of the data in order to change the functionality.</p> <p>It's also critical to have a secure way for parties to decide to upgrade the code. Depending on your contract, code changes may need to be approved by a single trusted party, a group of members, or a vote of the full set of stakeholders. If this process can take some time, you will want to consider if there are other ways to react more quickly in case of an attack, such as an emergency stop or circuit-breaker.</p> <p>Regardless of your approach, it is important to have some way to upgrade your contracts, or they will become unusable when the inevitable bugs are discovered in them.</p>"},{"location":"development-recommendations/precautions/upgradeability/#example-1-use-a-registry-contract-to-store-the-latest-version-of-a-contract","title":"Example 1: Use a registry contract to store the latest version of a contract","text":"<p>In this example, the calls aren't forwarded, so users should fetch the current address each time before interacting with it.</p> <pre><code>pragma solidity ^0.5.0;\n\ncontract SomeRegister {\n    address backendContract;\n    address[] previousBackends;\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner)\n        _;\n    }\n\n    function changeBackend(address newBackend) public\n    onlyOwner()\n    returns (bool)\n    {\n        if(newBackend != address(0) &amp;&amp; newBackend != backendContract) {\n            previousBackends.push(backendContract);\n            backendContract = newBackend;\n            return true;\n        }\n\n        return false;\n    }\n}\n</code></pre> <p>There are two main disadvantages to this approach:</p> <ol> <li>Users must always look up the current address, and anyone who fails to do so risks using an old    version of the contract</li> <li>You will need to think carefully about how to deal with the contract data when you replace the    contract</li> </ol> <p>The alternate approach is to have a contract forward calls and data to the latest version of the contract:</p>"},{"location":"development-recommendations/precautions/upgradeability/#example-2-use-a-delegatecall-to-forward-data-and-calls","title":"Example 2: Use a <code>DELEGATECALL</code> to forward data and calls","text":"<p>This approach relies on using the fallback function (in <code>Relay</code> contract) to forward the calls to a target contract (<code>LogicContract</code>) using delegatecall. Remember that <code>delegatecall</code> is a special function in Solidity that executes the logic of the called address (<code>LogicContract</code>) in the context of the calling contract (<code>Relay</code>), so \"storage, current address and balance still refer to the calling contract , only the code is taken from the called address\".</p> <pre><code>pragma solidity ^0.5.0;\n\ncontract Relay {\n    address public currentVersion;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor(address initAddr) {\n        require(initAddr != address(0));\n        currentVersion = initAddr;\n        owner = msg.sender; // this owner may be another contract with multisig, not a single contract owner\n    }\n\n    function changeContract(address newVersion) public\n    onlyOwner()\n    {\n        require(newVersion != address(0));\n        currentVersion = newVersion;\n    }\n\n    fallback() external payable {\n        (bool success, ) = address(currentVersion).delegatecall(msg.data);\n        require(success);\n    }\n}\n</code></pre> <pre><code>contract LogicContract {\n    address public currentVersion;\n    address public owner;\n    uint public counter;\n\n    function incrementCounter() {\n        counter++;\n    }\n}\n</code></pre> <p>This simple version of the pattern cannot return values from <code>LogicContract</code>'s functions, only forward them, which limits its applicability. More complex implementations attempt to solve this with in-line assembly code and a registry of return sizes. They are commonly referred to as Proxy Patterns, but are also known as Router, Dispatcher and Relay. Each implementation variant introduces a different set of complexity, risks and limitations.</p> <p>You must be extremely careful with how you store data with this method. If your new contract has a different storage layout than the first, your data may end up corrupted. When using more complex implementations of <code>delegatecall</code>, you should carefully consider and understand*:</p> <ul> <li>How the EVM handles the   layout of state variables in storage,   including packing multiple variables into a single storage slot if possible</li> <li>How and why   the order of inheritance impacts   the storage layout</li> <li>Why the called contract (<code>LogicContract</code>) must have the same storage layout of the calling   contract (<code>Relay</code>), and only append new variables to the storage (see   Background on delegatecall)</li> <li>Why a new version of the called contract (<code>LogicContract</code>)   must have the same storage layout as the previous version,   and only append new variables to the storage</li> <li>How a contract's constructor can affect upgradeability</li> <li>How the ABI specifies   function selectors   and how   function-name collision   can be used to exploit a contract that uses <code>delegatecall</code></li> <li>How <code>delegatecall</code> to a non-existent contract will return true even if the called contract does   not exist. For more details see   Breaking the proxy pattern   and Solidity docs on   Error handling.</li> <li>Remember the   importance of immutability to achieve trustlessness</li> </ul> <p>* Extended from Proxy pattern recommendations section</p>"},{"location":"development-recommendations/solidity-specific/abstract-vs-interfaces/","title":"Abstract vs Interfaces","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Be aware of the tradeoffs between abstract contracts and interfaces.</p> <p>Both interfaces and abstract contracts provide one with a customizable and re-usable approach for smart contracts. Interfaces, which were introduced in Solidity 0.4.11, are similar to abstract contracts but cannot have any functions implemented. Interfaces also have limitations such as not being able to access storage or inherit from other interfaces which generally makes abstract contracts more practical. Although, interfaces are certainly useful for designing contracts prior to implementation. Additionally, it is important to keep in mind that if a contract inherits from an abstract contract it must implement all non-implemented functions via overriding or it will be abstract as well.</p>"},{"location":"development-recommendations/solidity-specific/assert-require-revert/","title":"Assert, Require, Revert","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p>"},{"location":"development-recommendations/solidity-specific/assert-require-revert/#enforce-invariants-with-assert","title":"Enforce invariants with <code>assert()</code>","text":"<p>An assert guard triggers when an assertion fails - such as an invariant property changing. For example, the token to ether issuance ratio, in a token issuance contract, may be fixed. You can verify that this is the case at all times with an <code>assert()</code>. Assert guards should often be combined with other techniques, such as pausing the contract and allowing upgrades. (Otherwise, you may end up stuck, with an assertion that is always failing.)</p> <p>Example:</p> <pre><code>contract Token {\n    mapping(address =&gt; uint) public balanceOf;\n    uint public totalSupply;\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        totalSupply += msg.value;\n        assert(address(this).balance &gt;= totalSupply);\n    }\n}\n</code></pre> <p>Note that the assertion is not a strict equality of the balance because the contract can be forcibly sent ether without going through the <code>deposit()</code> function!</p>"},{"location":"development-recommendations/solidity-specific/assert-require-revert/#use-assert-require-revert-properly","title":"Use <code>assert()</code>, <code>require()</code>, <code>revert()</code> properly","text":"<p>Info</p> <p>The convenience functions assert and require can be used to check for conditions and throw an exception if the condition is not met.</p> <p>The assert function should only be used to test for internal errors, and to check invariants.</p> <p>The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts.</p> <p>Following this paradigm allows formal analysis tools to verify that the invalid opcode can never be reached: meaning no invariants in the code are violated and that the code is formally verified.</p> <pre><code>pragma solidity ^0.5.0;\n\ncontract Sharer {\n    function sendHalf(address payable addr) public payable returns (uint balance) {\n        require(msg.value % 2 == 0, \"Even value required.\"); //Require() can have an optional message string\n        uint balanceBeforeTransfer = address(this).balance;\n        (bool success, ) = addr.call.value(msg.value / 2)(\"\");\n        require(success);\n        // Since we reverted if the transfer failed, there should be\n        // no way for us to still have half of the money.\n        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2); // used for internal error checking\n        return address(this).balance;\n    }\n}\n</code></pre> <p>See SWC-110 &amp; SWC-123</p>"},{"location":"development-recommendations/solidity-specific/complex-inheritance/","title":"Complex Inheritance","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>When utilizing multiple inheritance in Solidity, it is important to understand how the compiler composes the inheritance graph.</p> <pre><code>contract Final {\n    uint public a;\n    function Final(uint f) public {\n        a = f;\n    }\n}\n\ncontract B is Final {\n    int public fee;\n\n    function B(uint f) Final(f) public {\n    }\n    function setFee() public {\n        fee = 3;\n    }\n}\n\ncontract C is Final {\n    int public fee;\n\n    function C(uint f) Final(f) public {\n    }\n    function setFee() public {\n        fee = 5;\n    }\n}\n\ncontract A is B, C {\n  function A() public B(3) C(5) {\n      setFee();\n  }\n}\n</code></pre> <p>When a contract is deployed, the compiler will linearize the inheritance from right to left (after the keyword is the parents are listed from the most base-like to the most derived). Here is contract A's linearization:</p> <p>Final \\&lt;- B \\&lt;- C \\&lt;- A</p> <p>The consequence of the linearization will yield a <code>fee</code> value of 5, since C is the most derived contract. This may seem obvious, but imagine scenarios where C is able to shadow crucial functions, reorder boolean clauses, and cause the developer to write exploitable contracts. Static analysis currently does not raise issue with overshadowed functions, so it must be manually inspected.</p> <p>For more on security and inheritance, check out this article</p> <p>To help contribute, Solidity's Github has a project with all inheritance-related issues.</p> <p>See SWC-125</p>"},{"location":"development-recommendations/solidity-specific/event-monitoring/","title":"Event Monitoring","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>It can be useful to have a way to monitor the contract's activity after it was deployed. One way to accomplish this is to look at all transactions of the contract, however that may be insufficient, as message calls between contracts are not recorded in the blockchain. Moreover, it shows only the input parameters, not the actual changes being made to the state. Also, events could be used to trigger functions in the user interface.</p> <pre><code>contract Charity {\n    mapping(address =&gt; uint) balances;\n\n    function donate() payable public {\n        balances[msg.sender] += msg.value;\n    }\n}\n\ncontract Game {\n    function buyCoins() payable public {\n        // 5% goes to charity\n        charity.donate.value(msg.value / 20)();\n    }\n}\n</code></pre> <p>Here, <code>Game</code> contract will make an internal call to <code>Charity.donate()</code>. This transaction won't appear in the external transaction list of <code>Charity</code>, but only visible in the internal transactions.</p> <p>An event is a convenient way to log something that happened in the contract. Events that were emitted stay in the blockchain along with the other contract data and they are available for future audit. Here is an improvement to the example above, using events to provide a history of the Charity's donations.</p> <pre><code>contract Charity {\n    // define event\n    event LogDonate(uint _amount);\n\n    mapping(address =&gt; uint) balances;\n\n    function donate() payable public {\n        balances[msg.sender] += msg.value;\n        // emit event\n        emit LogDonate(msg.value);\n    }\n}\n\ncontract Game {\n    function buyCoins() payable public {\n        // 5% goes to charity\n        charity.donate.value(msg.value / 20)();\n    }\n}\n</code></pre> <p>Here, all transactions that go through the <code>Charity</code> contract, either directly or not, will show up in the event list of that contract along with the amount of donated money.</p> <p>Prefer newer Solidity constructs</p> <p>Prefer constructs/aliases such as <code>selfdestruct</code> (over <code>suicide</code>) and <code>keccak256</code> (over <code>sha3</code>).  Patterns like <code>require(msg.sender.send(1 ether))</code> can also be simplified to using <code>transfer()</code>, as in <code>msg.sender.transfer(1 ether)</code>. Check out Solidity Change log for more similar changes.</p>"},{"location":"development-recommendations/solidity-specific/extcodesize-checks/","title":"EXTCODESIZE Checks","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Avoid using <code>extcodesize</code> to check for Externally Owned Accounts.</p> <p>The following modifier (or a similar check) is often used to verify whether a call was made from an externally owned account (EOA) or a contract account:</p> <pre><code>// bad\nmodifier isNotContract(address _a) {\n  uint size;\n  assembly {\n    size := extcodesize(_a)\n  }\n    require(size == 0);\n     _;\n}\n</code></pre> <p>The idea is straightforward: if an address contains code, it's not an EOA but a contract account. However, a contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but <code>extcodesize</code> for its address returns zero. Below is a minimal example that shows how this check can be circumvented:</p> <pre><code>contract OnlyForEOA {    \n    uint public flag;\n\n    // bad\n    modifier isNotContract(address _a){\n        uint len;\n        assembly { len := extcodesize(_a) }\n        require(len == 0);\n        _;\n    }\n\n    function setFlag(uint i) public isNotContract(msg.sender){\n        flag = i;\n    }\n}\n\ncontract FakeEOA {\n    constructor(address _a) public {\n        OnlyForEOA c = OnlyForEOA(_a);\n        c.setFlag(1);\n    }\n}\n</code></pre> <p>Because contract addresses can be pre-computed, this check could also fail if it checks an address which is empty at block <code>n</code>, but which has a contract deployed to it at some block greater than <code>n</code>.</p> <p>This issue is nuanced.</p> <p>If your goal is to prevent other contracts from being able to call your contract, the <code>extcodesize</code> check is probably sufficient. An alternative approach is to check the value of <code>(tx.origin == msg.sender)</code>, though this also has drawbacks.</p> <p>There may be other situations in which the <code>extcodesize</code> check serves your purpose. Describing all of them here is out of scope. Understand the underlying behaviors of the EVM and use your judgement.</p>"},{"location":"development-recommendations/solidity-specific/fallback-functions/","title":"Fallback Functions","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p>"},{"location":"development-recommendations/solidity-specific/fallback-functions/#keep-fallback-functions-simple","title":"Keep fallback functions simple","text":"<p>Fallback functions are called when a contract is sent a message with no arguments (or when no function matches), and only has access to 2,300 gas when called from a <code>.send()</code> or <code>.transfer()</code>. If you wish to be able to receive Ether from a <code>.send()</code> or <code>.transfer()</code>, the most you can do in a fallback function is log an event. Use a proper function if a computation of more gas is required.</p> <pre><code>// bad\nfunction() payable { balances[msg.sender] += msg.value; }\n\n// good\nfunction deposit() payable external { balances[msg.sender] += msg.value; }\n\nfunction() payable { require(msg.data.length == 0); emit LogDepositReceived(msg.sender); }\n</code></pre>"},{"location":"development-recommendations/solidity-specific/fallback-functions/#check-data-length-in-fallback-functions","title":"Check data length in fallback functions","text":"<p>Since the fallback functions is not only called for plain ether transfers (without data) but also when no other function matches, you should check that the data is empty if the fallback function is intended to be used only for the purpose of logging received Ether. Otherwise, callers will not notice if your contract is used incorrectly and functions that do not exist are called.</p> <pre><code>// bad\nfunction() payable { emit LogDepositReceived(msg.sender); }\n\n// good\nfunction() payable { require(msg.data.length == 0); emit LogDepositReceived(msg.sender); }\n</code></pre>"},{"location":"development-recommendations/solidity-specific/integer-division/","title":"Integer Division","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>All integer division rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator.</p> <p>(In the future, Solidity will have a fixed-point type, which will make this easier.)</p> <pre><code>// bad\nuint x = 5 / 2; // Result is 2, all integer division rounds DOWN to the nearest integer\n</code></pre> <p>Using a multiplier prevents rounding down, this multiplier needs to be accounted for when working with x in the future:</p> <pre><code>// good\nuint multiplier = 10;\nuint x = (5 * multiplier) / 2;\n</code></pre> <p>Storing the numerator and denominator means you can calculate the result of <code>numerator/denominator</code> off-chain:</p> <pre><code>// good\nuint numerator = 5;\nuint denominator = 2;\n</code></pre>"},{"location":"development-recommendations/solidity-specific/interface-types/","title":"Interface Types","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>When a function takes a contract address as an argument, it is better to pass an interface or contract type rather than a raw <code>address</code>. If the function is called elsewhere within the source code, the compiler will provide additional type safety guarantees.</p> <p>Here we see two alternatives:</p> <pre><code>contract Validator {\n    function validate(uint) external returns(bool);\n}\n\ncontract TypeSafeAuction {\n    // good\n    function validateBet(Validator _validator, uint _value) internal returns(bool) {\n        bool valid = _validator.validate(_value);\n        return valid;\n    }\n}\n\ncontract TypeUnsafeAuction {\n    // bad\n    function validateBet(address _addr, uint _value) internal returns(bool) {\n        Validator validator = Validator(_addr);\n        bool valid = validator.validate(_value);\n        return valid;\n    }\n}\n</code></pre> <p>The benefits of using the <code>TypeSafeAuction</code> contract above can then be seen from the following example. If <code>validateBet()</code> is called with an <code>address</code> argument, or a contract type other than <code>Validator</code>, the compiler will throw this error:</p> <pre><code>contract NonValidator{}\n\ncontract Auction is TypeSafeAuction {\n    NonValidator nonValidator;\n\n    function bet(uint _value) {\n        bool valid = validateBet(nonValidator, _value); // TypeError: Invalid type for argument in function call.\n                                                        // Invalid implicit conversion from contract NonValidator\n                                                        // to contract Validator requested.\n    }\n}\n</code></pre>"},{"location":"development-recommendations/solidity-specific/locking-pragmas/","title":"Locking Pragmas","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Contracts should be deployed with the same compiler version and flags that they have been tested the most with. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs. Contracts may also be deployed by others and the pragma indicates the compiler version intended by the original authors.</p> <pre><code>// bad\npragma solidity ^0.4.4;\n\n\n// good\npragma solidity 0.4.4;\n</code></pre> <p>Note: a floating pragma version (ie. <code>^0.4.25</code>) will compile fine with <code>0.4.26-nightly.2018.9.25</code>, however nightly builds should never be used to compile code for production.</p> <p>Warning</p> <p>Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.</p> <p>See SWC-103</p>"},{"location":"development-recommendations/solidity-specific/modifiers-as-guards/","title":"Modifiers as Guards","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>The code inside a modifier is usually executed before the function body, so any state changes or external calls will violate the Checks-Effects-Interactions pattern. Moreover, these statements may also remain unnoticed by the developer, as the code for modifier may be far from the function declaration. For example, an external call in modifier can lead to the reentrancy attack:</p> <pre><code>contract Registry {\n    address owner;\n\n    function isVoter(address _addr) external returns(bool) {\n        // Code\n    }\n}\n\ncontract Election {\n    Registry registry;\n\n    modifier isEligible(address _addr) {\n        require(registry.isVoter(_addr));\n        _;\n    }\n\n    function vote() isEligible(msg.sender) public {\n        // Code\n    }\n}\n</code></pre> <p>In this case, the <code>Registry</code> contract can make a reentrancy attack by calling <code>Election.vote()</code> inside <code>isVoter()</code>.</p> <p>Note</p> <p>Use modifiers to replace duplicate condition checks in multiple functions, such as <code>isOwner()</code>, otherwise use <code>require</code> or <code>revert</code> inside the function. This makes your smart contract code more readable and easier to audit.</p>"},{"location":"development-recommendations/solidity-specific/payability/","title":"Payability","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Starting from Solidity <code>0.4.0</code>, every function that is receiving ether must use <code>payable</code> modifier, otherwise if the transaction has <code>msg.value &gt; 0</code> will revert (except when forced).</p> <p>Note</p> <p>Something that might not be obvious: The <code>payable</code> modifier only applies to calls from external contracts. If I call a non-payable function in the payable function in the same contract, the non-payable function won't fail, though <code>msg.value</code> is still set.</p>"},{"location":"development-recommendations/solidity-specific/shadowing/","title":"Shadowing","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>It is currently possible to shadow built-in globals in Solidity. This allows contracts to override the functionality of built-ins such as <code>msg</code> and <code>revert()</code>. Although this is intended, it can mislead users of a contract as to the contract's true behavior.</p> <pre><code>contract PretendingToRevert {\n    function revert() internal constant {}\n}\n\ncontract ExampleContract is PretendingToRevert {\n    function somethingBad() public {\n        revert();\n    }\n}\n</code></pre> <p>Contract users (and auditors) should be aware of the full smart contract source code of any application they intend to use.</p>"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/","title":"Timestamp Dependence","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>There are three main considerations when using a timestamp to execute a critical function in a contract, especially when actions involve fund transfer.</p>"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/#timestamp-manipulation","title":"Timestamp Manipulation","text":"<p>Be aware that the timestamp of the block can be manipulated by a miner. Consider this contract:</p> <pre><code>uint256 constant private salt =  block.timestamp;\n\nfunction random(uint Max) constant private returns (uint256 result){\n    //get the best seed for randomness\n    uint256 x = salt * 100/Max;\n    uint256 y = salt * block.number/(salt % 5) ;\n    uint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;\n    uint256 h = uint256(block.blockhash(seed));\n\n    return uint256((h / x)) % Max + 1; //random number between 1 and Max\n}\n</code></pre> <p>When the contract uses the timestamp to seed a random number, the miner can actually post a timestamp within 15 seconds of the block being validated, effectively allowing the miner to precompute an option more favorable to their chances in the lottery. Timestamps are not random and should not be used in that context.</p>"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/#the-15-second-rule","title":"The 15-second Rule","text":"<p>The Yellow Paper (Ethereum's reference specification) does not specify a constraint on how much blocks can drift in time, but it does specify that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is:</p> <p>Note</p> <p>If the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a <code>block.timestamp</code>.</p>"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/#avoid-using-blocknumber-as-a-timestamp","title":"Avoid using <code>block.number</code> as a timestamp","text":"<p>It is possible to estimate a time delta using the <code>block.number</code> property and average block time, however this is not future proof as block times may change (such as fork reorganisations and the difficulty bomb). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time.</p> <p>See SWC-116</p>"},{"location":"development-recommendations/solidity-specific/tx-origin/","title":"tx.origin","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Never use <code>tx.origin</code> for authorization, another contract can have a method which will call your contract (where the user has some funds for instance) and your contract will authorize that transaction as your address is in <code>tx.origin</code>.</p> <pre><code>contract MyContract {\n\n    address owner;\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n\n    function sendTo(address receiver, uint amount) public {\n        require(tx.origin == owner);\n        (bool success, ) = receiver.call.value(amount)(\"\");\n        require(success);\n    }\n\n}\n\ncontract AttackingContract {\n\n    MyContract myContract;\n    address attacker;\n\n    function AttackingContract(address myContractAddress) public {\n        myContract = MyContract(myContractAddress);\n        attacker = msg.sender;\n    }\n\n    function() public {\n        myContract.sendTo(attacker, msg.sender.balance);\n    }\n\n}\n</code></pre> <p>You should use <code>msg.sender</code> for authorization (if another contract calls your contract <code>msg.sender</code> will be the address of the contract and not the address of the user who called the contract).</p> <p>You can read more about it here: Solidity docs</p> <p>Warning</p> <p>Besides the issue with authorization, there is a chance that <code>tx.origin</code> will be removed from the Ethereum protocol in the future, so code that uses <code>tx.origin</code> won't be compatible with future releases Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'</p> <p>It's also worth mentioning that by using <code>tx.origin</code> you're limiting interoperability between contracts because the contract that uses tx.origin cannot be used by another contract as a contract can't be the <code>tx.origin</code>.</p> <p>See SWC-115</p>"},{"location":"development-recommendations/solidity-specific/visibility/","title":"Visibility","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Explicitly label the visibility of functions and state variables. Functions can be specified as being <code>external</code>, <code>public</code>, <code>internal</code> or <code>private</code>. Please understand the differences between them, for example, <code>external</code> may be sufficient instead of <code>public</code>. For state variables, <code>external</code> is not possible. Labeling the visibility explicitly will make it easier to catch incorrect assumptions about who can call the function or access the variable.</p> <ul> <li><code>External</code> functions are part of the contract interface. An external function <code>f</code> cannot be   called internally (i.e. <code>f()</code> does not work, but <code>this.f()</code> works). External functions are   sometimes more efficient when they receive large arrays of data.</li> <li><code>Public</code> functions are part of the contract interface and can be either called internally or via   messages. For public state variables, an automatic getter function (see below) is generated.</li> <li><code>Internal</code> functions and state variables can only be accessed internally, without using <code>this</code>.</li> <li><code>Private</code> functions and state variables are only visible for the contract they   are defined in and not in derived contracts. Note: Everything inside a   contract is visible to all observers external to the   blockchain,   even <code>Private</code> variables.</li> </ul> <pre><code>// bad\nuint x; // the default is internal for state variables, but it should be made explicit\nfunction buy() { // the default is public\n    // public code\n}\n\n// good\nuint private y;\nfunction buy() external {\n    // only callable externally or using this.buy()\n}\n\nfunction utility() public {\n    // callable externally, as well as internally: changing this code requires thinking about both cases.\n}\n\nfunction internalAction() internal {\n    // internal code\n}\n</code></pre> <p>See SWC-100 and SWC-108</p>"},{"location":"development-recommendations/token-specific/contract-address/","title":"Contract Address","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Consider also preventing the transfer of tokens to the same address of the smart contract.</p> <p>An example of the potential for loss by leaving this open is the EOS token smart contract where more than 90,000 tokens are stuck at the contract address.</p>"},{"location":"development-recommendations/token-specific/contract-address/#example","title":"Example","text":"<p>An example of implementing both the above recommendations would be to create the following modifier; validating that the \"to\" address is neither 0x0 nor the smart contract's own address:</p> <pre><code>    modifier validDestination( address to ) {\n        require(to != address(0x0));\n        require(to != address(this) );\n        _;\n    }\n</code></pre> <p>The modifier should then be applied to the \"transfer\" and \"transferFrom\" methods:</p> <pre><code>    function transfer(address _to, uint _value)\n        validDestination(_to)\n        returns (bool) \n    {\n        (... your logic ...)\n    }\n\n    function transferFrom(address _from, address _to, uint _value)\n        validDestination(_to)\n        returns (bool) \n    {\n        (... your logic ...)\n    }\n</code></pre>"},{"location":"development-recommendations/token-specific/frontrunning/","title":"Frontrunning","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>The EIP-20 token's <code>approve()</code> function creates the potential for an approved spender to spend more than the intended amount. A front running attack can be used, enabling an approved spender to call <code>transferFrom()</code> both before and after the call to <code>approve()</code> is processed. More details are available on the EIP, and in this document.</p>"},{"location":"development-recommendations/token-specific/standardization/","title":"Standardization","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Generally speaking, smart contracts of tokens should follow an accepted and stable standard.</p> <p>Examples of currently accepted standards include:</p> <ul> <li>EIP20</li> <li>EIP721 (non-fungible token)</li> <li>More at eips.ethereum.org</li> </ul>"},{"location":"development-recommendations/token-specific/zero-address/","title":"Zero Address","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>At the time of writing, the \"zero\" address (0x0000000000000000000000000000000000000000) holds tokens with a value of more than 80$ million.</p>"},{"location":"general-philosophy/","title":"Index","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Ethereum and complex blockchain programs are new and highly experimental. Therefore, you should expect constant changes in the security landscape, as new bugs and security risks are discovered, and new best practices are developed. Following the security practices in this document is therefore only the beginning of the security work you will need to do as a smart contract developer.</p> <p>Smart contract programming requires a different engineering mindset than you may be used to. The cost of failure can be high, and change can be difficult, making it in some ways more similar to hardware programming or financial services programming than web or mobile development. It is therefore not enough to defend against known vulnerabilities. Instead, you will need to learn a new philosophy of development:</p>"},{"location":"general-philosophy/blockchain-properties/","title":"Blockchain Properties","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>While much of your programming experience will be relevant to Ethereum programming, there are some pitfalls to be aware of.</p> <ul> <li>Be extremely careful about external contract calls, which may execute malicious code and change   control flow.</li> <li>Understand that your public functions are public, and may be called maliciously and in any order.   The private data in smart contracts is also viewable by anyone.</li> <li>Keep gas costs and the block gas limit in mind.</li> <li>Be aware that timestamps are imprecise on a blockchain, miners can influence the time of   execution of a transaction within a margin of several seconds.</li> <li>Randomness is non-trivial on blockchain, most approaches to random number generation are gameable   on a blockchain.</li> </ul>"},{"location":"general-philosophy/prepare-for-failure/","title":"Prepare for Failure","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Any non-trivial contract will have errors in it. Your code must, therefore, be able to respond to bugs and vulnerabilities gracefully.</p> <ul> <li>Pause the contract when things are going wrong ('circuit breaker')</li> <li>Manage the amount of money at risk (rate limiting, maximum usage)</li> <li>Have an effective upgrade path for bugfixes and improvements</li> </ul>"},{"location":"general-philosophy/rollout/","title":"Rolling out","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>It is always better to catch bugs before a full production release.</p> <ul> <li>Test contracts thoroughly, and add tests whenever new attack vectors are discovered</li> <li>Provide bug bounties starting from alpha testnet   releases</li> <li>Rollout in phases, with increasing usage and testing in each phase</li> </ul>"},{"location":"general-philosophy/simplicity-vs-complexity/","title":"Simplicity vs. Complexity","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>There are multiple fundamental tradeoffs to consider when assessing the structure and security of a smart contract system. The general recommendation for any smart contract system is to identify the proper balance for these fundamental tradeoffs.</p> <p>An ideal smart contract system from a software engineering bias is modular, reuses code instead of duplicating it, and supports upgradeable components. An ideal smart contract system from a secure architecture bias may share this mindset, especially in the case of more complex smart contract systems.</p> <p>However, there are important exceptions where security and software engineering best practices may not be aligned. In each case, the proper balance is obtained by identifying the optimal mix of properties along contract system dimensions such as:</p> <ul> <li>Rigid versus Upgradeable</li> <li>Monolithic versus Modular</li> <li>Duplication versus Reuse</li> </ul>"},{"location":"general-philosophy/simplicity-vs-complexity/#rigid-versus-upgradeable","title":"Rigid versus Upgradeable","text":"<p>While multiple resources, including this one, emphasize malleability characteristics such as Killable, Upgradeable or Modifiable patterns there is a fundamental tradeoff between malleability and security.</p> <p>Malleability patterns by definition add complexity and potential attack surfaces. Simplicity is particularly effective over complexity in cases where the smart contract system performs a very limited set of functionality for a pre-defined limited period of time, for example, a governance-free finite-time-frame token-sale contract system.</p>"},{"location":"general-philosophy/simplicity-vs-complexity/#monolithic-versus-modular","title":"Monolithic versus Modular","text":"<p>A monolithic self-contained contract keeps all knowledge locally identifiable and readable. While there are few smart contract systems held in high regard that exist as monoliths, there is an argument to be made for extreme locality of data and flow - for example, in the case of optimizing code review efficiency.</p> <p>As with the other tradeoffs considered here, security best practices trend away from software engineering best practices in simple short-lived contracts and trend toward software engineering best practices in the case of more complex perpetual contract systems.</p>"},{"location":"general-philosophy/simplicity-vs-complexity/#duplication-versus-reuse","title":"Duplication versus Reuse","text":"<p>A smart contract system from a software engineering perspective wishes to maximize reuse where reasonable. There are many ways to reuse contract code in Solidity. Using proven previously-deployed contracts which you own is generally the safest manner to achieve code reuse.</p> <p>Duplication is frequently relied upon in cases where self-owned previously-deployed contracts are not available. Efforts such as OpenZeppelin's Solidity Library seek to provide patterns such that secure code can be re-used without duplication. Any contract security analysis must include any re-used code that has not previously established a level of trust commensurate with the funds at risk in the target smart contract system.</p>"},{"location":"general-philosophy/simplicity/","title":"Keep it Simple","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Complexity increases the likelihood of errors.</p> <ul> <li>Ensure the contract logic is simple</li> <li>Modularize code to keep contracts and functions small</li> <li>Use already-written tools or code where possible (eg. don't roll your own random number   generator)</li> <li>Prefer clarity to performance whenever possible</li> <li>Only use the blockchain for the parts of your system that require decentralization</li> </ul>"},{"location":"general-philosophy/stay-up-to-date/","title":"Stay up to Date","text":"<p>Tip</p> <p>For comprehensive insights into secure development practices, consider visiting the Development Recommendations section of the Smart Contract Security Field Guide. This resource provides in-depth articles to guide you in developing robust and secure smart contracts.</p> <p>Keep track of new security developments.</p> <ul> <li>Check your contracts for any new bug as soon as it is discovered</li> <li>Upgrade to the latest version of any tool or library as soon as possible</li> <li>Adopt new security techniques that appear useful</li> </ul>"},{"location":"security-tools/","title":"Index","text":"<p> This section is about tools that can detect vulnerabilities or help developers maintain a high code quality to reduce the likelihood and impact of vulnerabilities.</p> Category Description Visualization These tools are aimed at visualizing, EVM bytecode, smart contracts, and their control flow graphs. Static and Dynamic Analysis Tools that employ various means of program analysis to find vulnabilities and weaknesses. Classification Resources attempting to classify vulnerabilities and weaknesses in smart contracts. Testing Tools for running, measuring, and managing smart contract related tests. Linters and Formatters Any tools that highlight code smells and make smart contract code adhere to format standards. Disassemblers and Decompilers Tools that translate smart contract bytecode into opcodes and solidity code. Formal and Runtime Verification Tools employing verification techniques to detect behaviour satisfying or vioating invariants. <p>The Diligence Security Tooling Guide</p> <p>Download a free copy of the Diligence Security Tooling Guide to discover the top tools in Web3 you can use at any phase of your smart contract development to test and improve security.</p> Download guide"},{"location":"security-tools/classification/","title":"Classification","text":"<ul> <li>SWC-registry - SWC definitions and a   large repository of crafted and real-world samples of vulnerable smart contracts.</li> <li>SWC Pages - The SWC-registry repo   published on Github Pages</li> </ul>"},{"location":"security-tools/disassemblers/","title":"Disassemblers","text":"<p>Disassemblers</p> <p>Tools that translate smart contract bytecode into opcodes or EVM assembly.</p> <ul> <li>Ethersplay - Binary Ninja plugin which enables an EVM disassembler and related analysis tools. </li> <li>Pyevmasm - Assembler and disassembler library for the Ethereum Virtual Machine (EVM). It includes a commandline utility and a Python API.</li> <li>IDA-EVM - IDA Processor Module for the Ethereum Virtual Machine (EVM).</li> <li>Ethereum DASM - EVM bytecode disassembler with function signature lookup plus static and dynamic analysis.</li> </ul> <p>Decompilers</p> <p>As above but translated into more readable Solidity-like code.</p> <ul> <li>JEB Ethereum Smart Contract Decompiler - JEB decompiler plugin for Ethereum Smart Contracts</li> <li>Online Solidity Decompiler - Online tool that decompiles Ethereum contract bytecode into more readable Solidity-like code, allowing for better understanding of opaque/unverified contracts.</li> <li>Dedaub Decompiler - EVM bytecode decompiler and disassembler hybrid with 3 address code view deployed on a website.</li> </ul>"},{"location":"security-tools/linters-and-formatters/","title":"Linters and Formatters","text":"<p>Linters improve code quality by enforcing rules for style and composition, making code easier to read and review.</p> <ul> <li>Ethlint - Yet another Solidity linting.</li> <li>Solhint - A linter for Solidity that provides both   Security and Style Guide validations.</li> <li>Prettier +   Solidity Plugin - Prettier   enforces basic style conventions in your code.</li> </ul>"},{"location":"security-tools/static-and-dynamic-analysis/","title":"Static and Dynamic Analysis","text":"<ul> <li>MythX - MythX is a professional-grade cloud service that uses symbolic   analysis and input fuzzing to   detect common security bugs   and   verify the correctness of smart contract code.   Using MythX requires an API key from mythx.io.</li> <li>Mythril - The Swiss army knife for smart contract   security.</li> <li>Slither - Static analysis framework with detectors for   many common Solidity issues. It has taint and value tracking capabilities and is written in   Python.</li> <li>Contract-Library - Decompiler and security analysis tool for all   deployed contracts.</li> <li>MadMax - Static analysis tool for gas DoS   vulnerabilities.</li> <li>Gigahorse - Fast binary lifter and program   analysis framework written in Datalog.</li> <li>Echidna - The only available fuzzer for Ethereum   software. Uses property testing to generate malicious inputs that break smart contracts.</li> <li>Manticore - Dynamic binary analysis tool with   EVM support.</li> <li>Oyente - Analyze Ethereum code to find common   vulnerabilities, based on this paper.</li> <li>Securify - Fully automated online static analyzer for   smart contracts, providing a security report based on vulnerability patterns.</li> <li>SmartCheck - Static analysis of Solidity source code for security   vulnerabilities and best practices.</li> <li>Octopus - Security Analysis tool for Blockchain Smart   Contracts with support of EVM and (e)WASM.</li> <li>sFuzz - Efficient fuzzer inspired from AFL to find common   vulnerabilities.</li> <li>Vertigo - Mutation Testing for Ethereum Smart Contracts.</li> <li>SolidityScan - Vulnerability Scanner for Solidity Smart Contracts with over 200+ exploit and CVEs, misconfigurations, and gas optimization modules.</li> </ul>"},{"location":"security-tools/testing/","title":"Testing","text":"<ul> <li>solidity-coverage - Code coverage for Solidity   testing.</li> <li>solidity-shell - An interactive Solidity shell with lightweight session recording and remote compiler support.</li> <li>chisel - Chisel is a fast, utilitarian, and verbose solidity REPL. It is heavily inspired by the incredible work done in soli and solidity-shell!</li> <li>soli - Solidity REPL</li> </ul>"},{"location":"security-tools/verification/","title":"Verification","text":"<ul> <li>Scribble - Runtime verification tool for Solidity that enables you to write specifications to test, fuzz or symbolically execute contracts (e.g using Mythril or the MythX service) to check if your properties can be violated.</li> <li>KEVM - Formal verification framework that models EVM semantics.</li> <li>Certora Prover - Formal verification tool that checks if a smart contract satisfies a set of rules written in CVL (Certora Verification Language).</li> </ul>"},{"location":"security-tools/visualization/","title":"Visualization","text":"<ul> <li>Solidity Visual Developer   - This extension contributes security centric syntax and semantic highlighting, a detailed class   outline and advanced Solidity code insights to Visual Studio Code</li> <li>S\u016brya - Utility tool for smart contract systems, offering a   number of visual outputs and information about the contracts' structure. Also supports querying   the function call graph.</li> <li>Solgraph - Generates a DOT graph that visualizes   function control flow of a Solidity contract and highlights potential security vulnerabilities.</li> <li>EVM Lab - Rich tool package to interact with the EVM.   Includes a VM, Etherchain API, and a trace-viewer.</li> <li>ethereum-graph-debugger - A graphical EVM   debugger. Displays the entire program control flow graph.</li> <li>Piet - Web application helping understand smart contract   architectures. Offers graphical representation and inspection of smart contracts as well as a   markdown documentation generator.</li> </ul>"}]}